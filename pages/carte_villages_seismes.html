<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carte interactive</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.4/xlsx.full.min.js"></script>
    
    <style>
        body {
            display: flex;
            flex-direction: column; /* Change la direction en colonne */
            align-items: center; /* Centre les √©l√©ments */
            font-family: Arial, sans-serif;
            margin: 0; /* Supprime les marges par d√©faut */
        }

        #map {
            height: 90vh; /* Ajuste la hauteur pour laisser de la place en dessous */
            width: 100%;
        }

        #cities-list {
            width: 100%;
            text-align: center;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-top: 1px solid #ccc; /* Ajoute une s√©paration */
        }

        #filter-panel {
            position: absolute;
            top: 95px;
            left: 50px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 20px;
            z-index: 1000;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        label {
            display: block;
            margin-bottom: 8px;
        }

        #value-display {
            margin-top: 10px;
            font-size: 16px;
            font-weight: bold;
        }

        h4 {
            margin-top: 10px;
        }

        table {
            margin: 10px auto; /* Centre le tableau */
        }

        
    </style>
</head>
<body>
    <div id="filter-panel">
            <div id="excel-container">
        <button onclick="importVillages()">Importer les villages</button>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.1/xlsx.full.min.js"></script>
    
    <script>
        // Ta fonction readExcel d√©j√† d√©finie dans ton code
        function readExcel(data) {
            const workbook = XLSX.read(data, { type: 'array' });  // Lire le fichier Excel
            const sheetName = workbook.SheetNames[0];  // Prendre la premi√®re feuille
            const sheet = workbook.Sheets[sheetName];
    
            // Convertir la feuille en JSON
            const villagesData = XLSX.utils.sheet_to_json(sheet);
            console.log(villagesData);  // Affiche les donn√©es des villages pour v√©rification
    
            // Tu peux ajouter les villages √† la carte ici, comme dans ton code initial
            // addVillagesToMap(villagesData);
        }
    
        // Fonction pour t√©l√©charger le fichier Excel et l'importer
        function importVillages() {
            const excelUrl = 'https://raw.githubusercontent.com/VicoLeProgros/project_fani_maore/main/pages/types_batiments.xlsx';
            
            fetch(excelUrl)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Le fichier Excel n\'a pas pu √™tre t√©l√©charg√©.');
                    }
                    return response.arrayBuffer();  // R√©cup√©rer le fichier sous forme de buffer
                })
                .then(data => {
                    // Appeler ta fonction readExcel() avec les donn√©es t√©l√©charg√©es
                    readExcel(data);
                })
                .catch(error => {
                    console.error('Erreur lors du t√©l√©chargement du fichier Excel:', error);
                });
        }
    </script>

        <h2>Filtrer les villages</h1>
        <label for="filter-soil">Type de sol principal :</label>
        <select id="filter-soil">
            <option value="all">Tous</option>
            <option value="Terre Battue">Terre Battue</option>
            <option value="B√©ton">B√©ton</option>
            <option value="Carrelage">Carrelage</option>
        </select>
    
        <br></br>

        <label for="filter-vulnerability">Indice de vuln√©rabilit√© :</label>
        <input type="range" id="filter-vulnerability" min="0" max="100" step="1" value="0">
        <div id="vulnerability-display">Indice minimum : 0</div>

        <br>

        <label for="filter-population">Population minimale :</label>
        <input type="number" id="filter-population" min="0" value="0" step="1" />

        <br></br>
        <button onclick="readExcel()">Appliquer les filtres</button>
        <br>
    
        <h2>Rechercher un village</h2>
        <label for="village-select">S√©lectionner un village :</label>
        <select id="village-select">
            <option value="">-- Choisissez un village --</option>
        </select>

        <br>
        <h2>Cr√©ation d'un s√©isme</h1>
        <label for="filter-range">Magnitude (1 √† 10) :</label>
        <input type="range" id="filter-range" min="1" max="10" step="0.1" value="5">
        <div id="value-display">Magnitude choisie : 5</div>
    </div>

<div id="map"></div>

<div id="cities-list">
    <h3>Villes touch√©es :</h3>
    <ul id="cities"></ul>
</div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>

    // Initialisation de la carte
    var map = L.map('map').setView([-12.8516, 45.0485], 11);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

    // Ajout d'une l√©gende pour expliquer les couleurs des cercles
    var legend = L.control({ position: 'bottomright' });

    legend.onAdd = function(map) {
        var div = L.DomUtil.create('div', 'info legend');

        // Ajout du titre
        div.innerHTML = "<h4>Indice de vuln√©rabilit√©</h4>";

        var grades = [0, 50, 80]; // Seuils pour la vuln√©rabilit√©
        var labels = ['<strong>L√©gende</strong>'];

        // Fonction pour r√©cup√©rer la couleur correspondant aux indices de vuln√©rabilit√©
        function getColor(v) {
            return v >= 80 ? 'red' :
                v >= 50 ? 'orange' :
                            'green';
        }

        // G√©n√©rer les √©l√©ments de la l√©gende
        for (var i = 0; i < grades.length; i++) {
            div.innerHTML +=
                '<i style="background:' + getColor(grades[i]) + '; width: 18px; height: 18px; display: inline-block; margin-right: 5px;"></i> ' +
                (i === 0 ? 'Faible' : i === 1 ? 'Moyenne' : '√âlev√©e') + '<br>';
        }

        return div;
    };

    // Ajouter la l√©gende √† la carte
    legend.addTo(map);


    let villagesData = []; // Tableau pour stocker les donn√©es des villages


    
    function readExcel() {
        const fileInput = document.getElementById('excel-file');
        const file = fileInput.files[0];

        if (!file) {
            alert("Veuillez s√©lectionner un fichier Excel.");
            return;
        }

        const reader = new FileReader();
        reader.onload = function (e) {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: 'array' });
            const sheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[sheetName];

            villagesData = XLSX.utils.sheet_to_json(worksheet);

            if (villagesData.length === 0) {
                alert("Le fichier semble vide ou mal format√©.");
                return;
            }

            // Fonction pour mettre √† jour la liste d√©roulante avec les villages, tri√©s par ordre alphab√©tique
            function updateVillageSelect() {
                const villageSelect = document.getElementById('village-select');
                villageSelect.innerHTML = '<option value="">-- Choisissez un village --</option>'; // Vider l'ancienne liste

                // Trier les villages par nom alphab√©tiquement
                const sortedVillages = villagesData.sort((a, b) => {
                    const nameA = a["Nom Village"].toUpperCase(); // Ignorer la casse
                    const nameB = b["Nom Village"].toUpperCase(); // Ignorer la casse
                    if (nameA < nameB) {
                        return -1;
                    }
                    if (nameA > nameB) {
                        return 1;
                    }
                    return 0;
                });

                // Ajouter les villages tri√©s √† la liste d√©roulante
                sortedVillages.forEach(village => {
                    const option = document.createElement('option');
                    option.value = village["Nom Village"];
                    option.textContent = village["Nom Village"];
                    villageSelect.appendChild(option);
                });
            }

            // Appeler cette fonction apr√®s avoir charg√© les villages dans readExcel
            updateVillageSelect();

            // Nettoyage de la carte avant d'ajouter les nouveaux villages
            map.eachLayer(layer => {
                if (layer instanceof L.CircleMarker) {
                    map.removeLayer(layer);
                }
            });

            // R√©cup√©rer les filtres
            const selectedSoil = document.getElementById('filter-soil').value;
            const minVulnerability = parseFloat(document.getElementById('filter-vulnerability').value);
            const minPopulation = parseFloat(document.getElementById('filter-population').value);

            // Seuils de normalisation coh√©rents avec addVillageToMap()
            const maxPopulation = 17733;  // maximum th√©orique de population
            const maxPctTerre = 100;      // 100% de terre
            const maxhablogements = 5.1;
            const maxIndiceVulnerabilite = (maxPctTerre * 3) * Math.log2(maxPopulation) * maxhablogements;

            // Ajout des villages filtr√©s sur la carte
            villagesData.forEach(village => {
                if (village["Latitude"] && village["Longitude"]) {
                    let lat = parseFloat(village["Latitude"].toString().replace(",", "."));
                    let lng = parseFloat(village["Longitude"].toString().replace(",", "."));

                    if (!isNaN(lat) && !isNaN(lng)) {
                        const totalLogements = parseFloat(village["Total"] || 0);
                        const popMoyLogement = parseFloat(village["Nombre moyen de personnes par logement"] || 0);
                        const population = totalLogements * popMoyLogement;

                        const pctTerre = totalLogements ? (village["Sol en terre battue"] / totalLogements * 100) : 0;
                        const pctBeton = totalLogements ? (village["Sol en beton"] / totalLogements * 100) : 0;
                        const pctCarrelage = totalLogements ? (village["Sol en carrelage ou autre"] / totalLogements * 100) : 0;

                        const logPopulation = population > 0 ? Math.log2(population) : 1;
                        const indiceVulnerabiliteBrut = (pctTerre * 3 + pctBeton * 2 + pctCarrelage * 1) * logPopulation * popMoyLogement;

                        // Normalisation de l'indice pour √™tre entre 0 et 100
                        const indiceNormalise = Math.min(Math.max((indiceVulnerabiliteBrut / maxIndiceVulnerabilite) * 100, 0), 100);

                        let mainSoil = "Autre";
                        if (pctTerre > pctBeton && pctTerre > pctCarrelage) mainSoil = "Terre Battue";
                        else if (pctBeton > pctCarrelage) mainSoil = "B√©ton";
                        else mainSoil = "Carrelage";

                        // Appliquer les filtres
                        if ((selectedSoil === "all" || selectedSoil === mainSoil) &&
                            indiceNormalise >= minVulnerability &&
                            population >= minPopulation) {
                            addVillageToMap(village);
                        }
                    }
                }
            });
        };

        reader.readAsArrayBuffer(file);
    }


    // Fonction de recherche de village
    function searchVillage() {
        const searchTerm = document.getElementById('search-village').value.toLowerCase(); // R√©cup√®re le texte de recherche et le convertit en minuscules

        if (!searchTerm) {
            alert("Veuillez entrer un nom de village.");
            return;
        }

        // Nettoyer la carte avant de rajouter les villages filtr√©s
        map.eachLayer(layer => {
            if (layer instanceof L.CircleMarker) {
                map.removeLayer(layer);
            }
        });

        // Filtrer les villages par nom
        villagesData.forEach(village => {
            const villageName = village["Nom Village"].toLowerCase();
            
            if (villageName.includes(searchTerm) && village["Latitude"] && village["Longitude"]) {
                let lat = parseFloat(village["Latitude"].toString().replace(",", "."));
                let lng = parseFloat(village["Longitude"].toString().replace(",", "."));

                if (!isNaN(lat) && !isNaN(lng)) {
                    addVillageToMap(village); // Ajouter le village filtr√© √† la carte
                }
            }
        });
    }

    // Fonction pour ajouter un village √† la carte
    function addVillageToMap(village) {
        // V√©rification et correction des latitudes/longitudes
        let lat = village["Latitude"];
        let lng = village["Longitude"];

        if (typeof lat === "string") lat = parseFloat(lat.replace(",", "."));
        if (typeof lng === "string") lng = parseFloat(lng.replace(",", "."));

        if (!isNaN(lat) && !isNaN(lng)) {
            

            // V√©rification et conversion des valeurs
            const totalLogements = village["Total"] ? parseFloat(village["Total"]) : 0;
            const popMoyLogement = village["Nombre moyen de personnes par logement"] ? parseFloat(village["Nombre moyen de personnes par logement"]) : 0;
            const population = totalLogements * popMoyLogement;

            // Calcul des pourcentages de sols
            const pctTerre = totalLogements ? (village["Sol en terre battue"] / totalLogements * 100) : 0;
            const pctBeton = totalLogements ? (village["Sol en beton"] / totalLogements * 100) : 0;
            const pctCarrelage = totalLogements ? (village["Sol en carrelage ou autre"] / totalLogements * 100) : 0;

            // Calcul de l'indice de vuln√©rabilit√© brut
            const logPopulation = population > 0 ? Math.log2(population) : 1;
            const habitantsParLogement = village["Nombre moyen de personnes par logement"];  // Nombre moyen d'habitants par logement

            // Calcul de l'indice de vuln√©rabilit√© en tenant compte du nombre d'habitants par logement
            const indiceVulnerabiliteBrut = (pctTerre * 3 + pctBeton * 2 + pctCarrelage * 1) * logPopulation * habitantsParLogement;

            // Seuils maximum et minimum possibles pour les calculs
            const maxPopulation = 17733;  // maximum th√©orique de population
            const maxPctTerre = 100;      // 100% de terre
            const maxhablogements = 5.1;

            // Calcul de l'indice normalis√© entre 0 et 100
            const maxIndiceVulnerabilite = (maxPctTerre * 3) * Math.log2(maxPopulation) * maxhablogements;
            const indiceNormalise = (indiceVulnerabiliteBrut / maxIndiceVulnerabilite) * 100;

            const indiceNormaliseArrondi = Math.min(Math.max(indiceNormalise, 0), 100).toFixed(2);

            // Fonction pour d√©terminer la couleur du cercle
            function getColorByVulnerability(indiceNormaliseArrondi) {
                if (indiceNormaliseArrondi >= 80) return "red";       // Tr√®s vuln√©rable üî¥
                if (indiceNormaliseArrondi >= 50) return "orange";    // Moyennement vuln√©rable üü†
                return "green";                       // Peu vuln√©rable üü¢
            }

            // Cr√©ation d'un cercle de taille fixe (rayon = 8)
            const marker = L.circleMarker([lat, lng], {
                radius: 5,  // Taille fixe pour tous les villages
                color: getColorByVulnerability(indiceNormaliseArrondi),
                fillColor: getColorByVulnerability(indiceNormaliseArrondi),
                fillOpacity: 0.7,
            }).addTo(map);

            // Ajout d'un popup avec les informations
            marker.bindPopup(`
                <strong>${village["Nom Village"]}</strong><br>
                Sol en Terre Battue: ${pctTerre.toFixed(1)}%<br>
                Sol en B√©ton: ${pctBeton.toFixed(1)}%<br>
                Sol en Carrelage: ${pctCarrelage.toFixed(1)}%<br>
                Total logements: ${totalLogements}<br>
                <strong>Population estim√©e: ${Math.round(population)}</strong><br>
                Population moyenne par logement: ${popMoyLogement.toFixed(1)}<br>
                <strong>Indice de Vuln√©rabilit√©: ${indiceNormaliseArrondi}</strong>
            `);

    
        } else {
            console.warn("Coordonn√©es invalides pour", village["Nom Village"]);
        }
    }

    var previousMarker = null;
    var previousCircles = [];

    // Calcul de la distance entre deux points
    function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371000;  // Rayon de la Terre en m√®tres
        const œÜ1 = lat1 * Math.PI / 180;
        const œÜ2 = lat2 * Math.PI / 180;
        const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
        const ŒîŒª = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(ŒîœÜ / 2) ** 2 + Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª / 2) ** 2;
        return R * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))); // Retourne la distance en m√®tres
    }

    // Calcul de l'intensit√© ressentie √† une ville
    function intensityAtCity(lat1, lon1, lat2, lon2, magnitude, beta) {
        let distance = calculateDistance(lat1, lon1, lat2, lon2) / 1000; // Distance en km
        distance = Math.max(distance, 1); // Distance minimale de 1 km pour √©viter une division par z√©ro
        return Math.max(magnitude - beta * Math.log10(distance), 0);  // Formule de l'intensit√©
    }

    // Cat√©gorie de l'intensit√© ressentie
    function getIntensityCategory(intensity) {
        if (intensity >= 7) return '√âlev√©e';
        if (intensity >= 4) return 'Moyenne';
        return 'Faible';
    }

    function updateCitiesList(lat, lng, radius, magnitude) {
        const beta = 4; // Coefficient terrain rocheux, ajuster si n√©cessaire
        const categorizedCities = { '√âlev√©e': [], 'Moyenne': [], 'Faible': [] };

        villagesData.forEach(village => {
            const villageLat = parseFloat(village["Latitude"].toString().replace(",", "."));
            const villageLng = parseFloat(village["Longitude"].toString().replace(",", "."));

            if (!isNaN(villageLat) && !isNaN(villageLng)) {
                const distance = calculateDistance(lat, lng, villageLat, villageLng);
                const intensity = intensityAtCity(lat, lng, villageLat, villageLng, magnitude, beta);
                const category = getIntensityCategory(intensity);

                if (distance <= radius) {
                    categorizedCities[category].push({
                        name: village["Nom Village"],
                        distance: distance,
                        intensity: intensity.toFixed(2)
                    });
                }
            }
        });

        const citiesList = document.getElementById('cities');
        citiesList.innerHTML = ''; // Vide la liste existante
        const fragment = document.createDocumentFragment();

        Object.keys(categorizedCities).forEach(category => {
            if (categorizedCities[category].length > 0) {
                categorizedCities[category].sort((a, b) => b.intensity - a.intensity);

                // Ajouter un titre pour chaque cat√©gorie
                let header = document.createElement('h4');
                header.textContent = category;
                fragment.appendChild(header);

                // Cr√©er un tableau pour cette cat√©gorie
                let table = document.createElement('table');
                table.style.width = "60%";
                table.style.borderCollapse = "collapse";

                // Ajouter l'en-t√™te du tableau
                let thead = document.createElement('thead');
                thead.innerHTML = `
                    <tr>
                        <th style="border: 1px solid #000; padding: 3px;">Nom du village</th>
                        <th style="border: 1px solid #000; padding: 3px;">Distance (km)</th>
                        <th style="border: 1px solid #000; padding: 3px;">Intensit√©</th>
                    </tr>`;
                table.appendChild(thead);

                let tbody = document.createElement('tbody');
                categorizedCities[category].forEach(city => {
                    let row = document.createElement('tr');
                    row.innerHTML = `
                        <td style="border: 1px solid #000; padding: 3px;">${city.name}</td>
                        <td style="border: 1px solid #000; padding: 3px;">${Math.round(city.distance / 1000)}</td>
                        <td style="border: 1px solid #000; padding: 3px;">${city.intensity}</td>
                    `;
                    tbody.appendChild(row);
                });
                table.appendChild(tbody);
                fragment.appendChild(table);
            }
        });

        citiesList.appendChild(fragment);
    }

    
    // Fonction pour animer un cercle (agrandir son rayon)
    function animateCircle(circle, targetRadius, duration) {
        let step = targetRadius / 30;  // Diviser le rayon en 30 √©tapes
        let radius = 0;
        let interval = setInterval(() => {
            radius += step;
            circle.setRadius(radius);
            if (radius >= targetRadius) clearInterval(interval);  // Arr√™ter l'animation une fois le rayon atteint
        }, duration / 30);
    }

    function createGradientCircle(lat, lng, magnitude) {
        if (previousMarker) {
            map.removeLayer(previousMarker);
            previousCircles.forEach(circle => map.removeLayer(circle));
            previousCircles = [];
        }

        var marker = L.marker([lat, lng]).addTo(map)
            .bindPopup("S√©isme : Magnitude " + magnitude + "<br><strong>Cliquez pour supprimer</strong>");

        var maxRadius = Math.pow(10, (0.5 * magnitude - 1.8)) * 1000;
        
        // Tracer le plus grand cercle en premier
        let outerCircle = L.circle([lat, lng], {
            color: "black",
            fillColor: "black",
            fillOpacity: 0.1,
            radius: maxRadius
        }).addTo(map);
        previousCircles.push(outerCircle);

        // Nombre de points pour tracer le rayon
        let steps = 100;
        let beta = 4;
        let lastIntensity = null;

        for (let i = 0; i <= steps; i++) {
            let fraction = i / steps;
            let pointLat = lat + fraction * (maxRadius / 111320); // 111320m ‚âà 1¬∞ latitude
            let pointLng = lng;

            let intensity = Math.floor(intensityAtCity(lat, lng, pointLat, pointLng, magnitude, beta));

            // Si l'intensit√© change d'un entier, on trace un cercle
            if (intensity !== lastIntensity) {
                let circle = L.circle([lat, lng], {
                    color: getColorFromIntensity(intensity),
                    fillColor: getColorFromIntensity(intensity),
                    fillOpacity: 0.1,
                    radius: fraction * maxRadius
                }).addTo(map);
                previousCircles.push(circle);
            }
            lastIntensity = intensity;
        }

        updateCitiesList(lat, lng, maxRadius, magnitude);
        previousMarker = marker;

        marker.on('click', function() {
            map.removeLayer(marker);
            previousCircles.forEach(circle => map.removeLayer(circle));
        });
    }

    // Fonction pour obtenir la couleur en fonction de l'intensit√© ressentie
    function getColorFromIntensity(intensity) {
        let hue = 240 - (intensity * 30); // 240 (bleu) -> 0 (rouge)
        return `hsl(${hue}, 100%, 50%)`;
    }

    // √âv√©nement de clic sur la carte pour simuler un s√©isme
    map.on('click', function(e) {
        var magnitude = parseFloat(document.getElementById('filter-range').value);
        createGradientCircle(e.latlng.lat, e.latlng.lng, magnitude);
    });

    // √âv√©nement pour mettre √† jour l'affichage de la magnitude
    var rangeInput = document.getElementById('filter-range');
    var valueDisplay = document.getElementById('value-display');
    rangeInput.addEventListener('input', function() {
        valueDisplay.textContent = "Magnitude choisie : " + rangeInput.value;
    });

    // √âv√©nement pour mettre √† jour l'affichage de l'indice de vuln√©rabilit√©
    var vulnerabilityInput = document.getElementById('filter-vulnerability');
    var vulnerabilityDisplay = document.getElementById('vulnerability-display');
    vulnerabilityInput.addEventListener('input', function() {
        vulnerabilityDisplay.textContent = "Indice minimum : " + this.value;
    });

    // Affichage de la valeur du curseur de magnitude
    var rangeInput = document.getElementById('filter-range');
    var valueDisplay = document.getElementById('value-display');
    rangeInput.addEventListener('input', function() {
        valueDisplay.textContent = "Magnitude choisie : " + rangeInput.value;
    });

    document.getElementById('village-select').addEventListener('change', function() {
        const selectedVillageName = this.value;

        // Chercher le village s√©lectionn√© dans les donn√©es
        const selectedVillage = villagesData.find(village => village["Nom Village"] === selectedVillageName);

        if (selectedVillage && selectedVillage["Latitude"] && selectedVillage["Longitude"]) {
            const lat = parseFloat(selectedVillage["Latitude"].toString().replace(",", "."));
            const lng = parseFloat(selectedVillage["Longitude"].toString().replace(",", "."));

            if (!isNaN(lat) && !isNaN(lng)) {
                // Centrer la carte sur le village s√©lectionn√©
                map.setView([lat, lng], 15);  // 13 pour un niveau de zoom plus proche
            }
        }
    });
</script>

</body>
</html>
